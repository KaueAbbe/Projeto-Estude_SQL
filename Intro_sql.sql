/* CRIANDO UMA TABELA SQL
** VARCHAR SERVE PARA STRINGS COM POSIÇÃO SELECIONADAS
** FLOAT É UM SUBTIPO DE NUMBER*/  
CREATE TABLE TABELA_DE_VENDEDORES (
MATRICULA VARCHAR (5)PRIMARY KEY,
NOME VARCHAR (100),
PERCENTUAL_COMISSAO FLOAT);
/* CRIANDO SEGUNDA TABELA PARA APAGAR*/ 
CREATE TABLE TABELA_DE_VENDEDORES2 (
MATRICULA VARCHAR (5)PRIMARY KEY,
NOME VARCHAR (100),
PERCENTUAL_COMISSAO FLOAT);

DROP TABLE TABELA_DE_VENDEDORES2;

/* INSERIR VENDEDORES NA TABELA DE VENDEDORES*/
INSERT INTO tabela_de_vendedores(
MATRICULA, NOME, percentual_comissao) 
VALUES ('00233', 'José Geraldo da Fonseca', 0.1);

INSERT INTO tabela_de_vendedores(
MATRICULA, NOME, PERCENTUAL_COMISSAO) 
VALUES ('00235', 'Márcio Almeida Silva', 0.08);
INSERT INTO tabela_de_vendedores(
MATRICULA, NOME, PERCENTUAL_COMISSAO) 
VALUES ('00236', 'Cláudia Morais', 0.08);

/*ATUALIZAÇÃO DO REGISTRO
** A Claudia passsou a ter comissão de 11% 
** O José reclamou que seu nome é na verdade José Geraldo da Fonseca Júnior*/
UPDATE TABELA_DE_VENDEDORES SET PERCENTUAL_COMISSAO = 0.11
WHERE MATRICULA = '00236';
UPDATE TABELA_DE_VENDEDORES SET NOME = 'José Geraldo da Fonseca Júnior'
WHERE MATRICULA = '00235';

/*Cometi um erro na atualização do vendedor, vou arrumar. O José não tem essa matricula*/
UPDATE TABELA_DE_VENDEDORES SET NOME = 'José Geraldo da Fonseca Júnior'
WHERE MATRICULA = '00233';
UPDATE TABELA_DE_VENDEDORES SET NOME = 'Márcio Almeida Silva'
WHERE MATRICULA = '00235';


/*Vamos apagar e alterar toda a tabela */
DROP TABLE TABELA_DE_VENDEDORES;
CREATE TABLE TABELA_DE_VENDEDORES (
     MATRICULA VARCHAR(5),
     NOME VARCHAR(100),
     PERCENTUAL_COMISSAO FLOAT,
     DATA_ADMISSAO DATE,
     DE_FERIAS NUMBER(1)
);
ALTER TABLE TABELA_DE_VENDEDORES ADD CONSTRAINT PK_TABELA_DE_VENDEDORES PRIMARY KEY (MATRICULA);
INSERT INTO TABELA_DE_VENDEDORES (
     MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO, DE_FERIAS
) VALUES (
     '00235','Márcio Almeida Silva',0.08,TO_DATE('15/08/2014','DD/MM/YYYY'),0
);
INSERT INTO TABELA_DE_VENDEDORES (
     MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO,DE_FERIAS
) VALUES (
     '00236','Cláudia Morais',0.08,TO_DATE('17/09/2013','DD/MM/YYYY'),1
);
INSERT INTO TABELA_DE_VENDEDORES (
     MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO,DE_FERIAS
) VALUES (
     '00237','Roberta Martins',0.11,TO_DATE('18/03/2017','DD/MM/YYYY'),1
);
INSERT INTO TABELA_DE_VENDEDORES (
     MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO,DE_FERIAS
) VALUES (
     '00238','Péricles Alves',0.11,TO_DATE('21/08/2016','DD/MM/YYYY'),0
);


/*Como fazer seleções na tabela?*/
SELECT NOME, MATRICULA FROM tabela_de_vendedores;

SELECT * FROM tabela_de_vendedores;

SELECT * FROM TABELA_DE_VENDEDORES WHERE de_ferias = 1;

/*Como está a vendedora Cláudia Morais?*/
SELECT * FROM TABELA_DE_VENDEDORES WHERE NOME = 'Cláudia Morais';

/*Obtendo valores de comissão maior que 10%*/
SELECT * FROM TABELA_DE_VENDEDORES WHERE PERCENTUAL_COMISSAO > 0.10;

/*Quais vendedores foram admitidos 2016 adiante na loja?*/
SELECT * FROM TABELA_DE_VENDEDORES WHERE TO_CHAR(DATA_ADMISSAO, 'YYYY') >='2016';


/*Selecionando pessoas de férias que foram admitidas antes de 2016*/
SELECT * FROM TABELA_DE_VENDEDORES WHERE TO_CHAR(DATA_ADMISSAO, 'YYYY') < '2017' AND
DE_FERIAS = 1;

SELECT * FROM TABELA_DE_VENDEDORES;

/*COMO USAR O COMANDO NOT? 
O NOT SERVE PRA TRAZER O CONTRÁRIO DO QUE FOI PEDIDO.
VAMOS PEGAR OS VENDEDORES QUE NÃO ESTÃO DE FÉRIAS*/
SELECT * FROM TABELA_DE_VENDEDORES WHERE NOT(DE_FERIAS = 1);

/*PEGAR OS DADOS USANDO O COMANDO IN, MUITO ÚTIL PARA DADOS DE DIFERENTES TIPOS*/
SELECT * FROM TABELA_DE_VENDEDORES WHERE DE_FERIAS IN (0);

/*O DISTINCT SELECIONA OS VALORES ÚNICOS DA TABELA*/
SELECT DISTINCT DE_FERIAS FROM TABELA_DE_VENDEDORES;
SELECT DISTINCT DE_FERIAS, PERCENTUAL_COMISSAO FROM TABELA_DE_VENDEDORES;

/*ROWNUM SELECIONA ATÉ A X LINHA ROWNUM <= X*/
SELECT* FROM TABELA_DE_VENDEDORES WHERE ROWNUM <= 2;

/*O ORDER BY IRÁ ORDERNAR ALFABETICAMENTE, PODENDO ESPECIFICAR PRA DESCENDENTE
PARA TER O RESULTADO DO MAIOR PRO MENOR*/
SELECT * FROM TABELA_DE_VENDEDORES ORDER BY PERCENTUAL_COMISSAO;
SELECT * FROM TABELA_DE_VENDEDORES ORDER BY PERCENTUAL_COMISSAO DESC;
SELECT * FROM TABELA_DE_VENDEDORES ORDER BY PERCENTUAL_COMISSAO DESC, NOME ASC;

/*GROUP BY FORMA GRUPOS E APLICA OPERAÇÕES NESSES GRUPOS
O GROUP BY DEVERÁ SEMPRE FICAR NO FIM*/
SELECT EMBALAGEM, MAX(PRECO_DE_LISTA) AS MAIOR_PRECO FROM TABELA_DE_PRODUTOS GROUP BY EMBALAGEM;
/*MAX RETORNA O MAIOR VALOR
MIN RETORNA O MENOR VALOR
AVG RETORNA A MÉDIA
SUM RETORNA A SOMA
COUNT RETORNA A FREQUÊNCIA
*/

/*CASE APLICA UMA CONDIÇÃO DE CASO*/
SELECT NOME_DO_PRODUTO, PRECO_DE_LISTA,
(CASE WHEN PRECO_DE_LISTA >=12 THEN 'PRODUTO CARO'
      WHEN PRECO_DE_LISTA >= 7 AND PRECO_DE_LISTA < 12 THEN 'EM CONTA'
      ELSE 'BARATO'
      END) AS STATUS
      FROM TABELA_DE_PRODUTOS;

SELECT NOME_DO_PRODUTO, PRECO_DE_LISTA,
(CASE WHEN PRECO_DE_LISTA >=12 THEN 'PRODUTO CARO'
      WHEN PRECO_DE_LISTA >= 7 AND PRECO_DE_LISTA < 12 THEN 'EM CONTA'
      ELSE 'BARATO'
      END) AS STATUS
      FROM TABELA_DE_PRODUTOS WHERE SABOR = 'Manga';

SELECT EMBALAGEM, 
(CASE WHEN PRECO_DE_LISTA >=12 THEN 'PRODUTO CARO'
      WHEN PRECO_DE_LISTA >= 7 AND PRECO_DE_LISTA < 12 THEN 'EM CONTA'
      ELSE 'BARATO'
      END) AS STATUS,
      AVG(PRECO_DE_LISTA) AS MEDIA
      FROM TABELA_DE_PRODUTOS
      GROUP BY EMBALAGEM, (CASE WHEN PRECO_DE_LISTA >=12 THEN 'PRODUTO CARO'
      WHEN PRECO_DE_LISTA >= 7 AND PRECO_DE_LISTA < 12 THEN 'EM CONTA'
      ELSE 'BARATO'
      END);
      
SELECT NOME, 
(CASE WHEN TO_CHAR(DATA_DE_NASCIMENTO,'YYYY') < 1990 THEN 'VELHO'
      WHEN TO_CHAR(DATA_DE_NASCIMENTO,'YYYY') < 1995 AND TO_CHAR(DATA_DE_NASCIMENTO,'YYYY') >= 1990 THEN 'JOVENS'
      ELSE 'CRIANÇA'
      END) AS STATUS
      FROM TABELA_DE_CLIENTES;
      
/*O HAVING É UM FILTRO APLICANDO EM CIMA DO GROUP BY */
SELECT SUM(LIMITE_DE_CREDITO) AS SOMA_LIMITE
FROM TABELA_DE_CLIENTES GROUP BY ESTADO
HAVING SUM(LIMITE_DE_CREDITO) >= 900000;

SELECT EMBALAGEM, MAX(PRECO_DE_LISTA) AS MAIOR_PRECO, MIN(PRECO_DE_LISTA)AS MENOR_PRECO
FROM TABELA_DE_PRODUTOS GROUP BY EMBALAGEM
HAVING SUM(PRECO_DE_LISTA) <= 80;

SELECT CPF FROM NOTAS_FISCAIS 
WHERE TO_CHAR(DATA_VENDA, 'YYYY') = 2016
GROUP BY CPF HAVING COUNT(*) >2000;

SELECT CPF, COUNT(CPF) AS CONTAGEM
FROM NOTAS_FISCAIS
WHERE TO_CHAR(DATA_VENDA, 'YYYY') = 2016
GROUP BY CPF;

/*INNER JOIN É UMA FORMA DE UNIR TABELAS DIFERENTES POR COLUNAS DE MESMO NOME*/
/*NESTE COMANDO EU AGRUPO POR ANO E FAÇO A SOMA DO PRODUTO QUANTIDADE E PREÇO. O INNER JOIN SERVE PARA
ATRIBRUI AS OUTRAS COLUNAS AOS NUMEROS IDENTICOS DAS DUAS TABELAS*/
SELECT * FROM ITENS_NOTAS_FISCAIS;
SELECT * FROM NOTAS_FISCAIS;
SELECT TO_CHAR(DATA_VENDA, 'YYYY'), SUM(QUANTIDADE * PRECO) AS FATURAMENTO/* SELECIONA O QUE QUER*/
FROM NOTAS_FISCAIS A INNER JOIN ITENS_NOTAS_FISCAIS B 
ON A.NUMERO = B.NUMERO/*FAZ O INNER JOIN*/  /*FAZ O AGRUPAMENTO*/
GROUP BY TO_CHAR(DATA_VENDA, 'YYYY') 

/*EXISTE AINDA LEFT JOIN E RIGHT JOIN QUE DÃO PRIORIDADES AOS LADOS*/
SELECT DISTINCT A.CPF AS CPF_CADASTRO,
A.NOME, B.CPF AS CPF_NOTA
FROM TABELA_DE_CLIENTES A RIGHT JOIN NOTAS_FISCAIS B
ON A.CPF = B.CPF

/*EXITE FULL JOIN QUE FAZ UNI AS TABELAS DOS DOIS LADOS. O QUE É NULO
SIGNIFICA QUE NÃO HOUVE PAREAMENTE ENTRE AS COLUNAS. 
EXISTE O CROSS JOIN QUE UNE CADA LINHA DA TABELA A COM TODAS AS LINHAS DA TABELA B*/
SELECT TABELA_DE_VENDEDORES.NOME AS NOME_VENDEDORES
,TABELA_DE_VENDEDORES.BAIRRO AS BAIRRO_VENDEDOR
,TABELA_DE_CLIENTES.NOME AS NOME_CLIENTES
,TABELA_DE_CLIENTES.BAIRRO AS BAIRRO_CLIENTES
FROM TABELA_DE_VENDEDORES FULL JOIN TABELA_DE_CLIENTES
ON TABELA_DE_VENDEDORES.BAIRRO = TABELA_DE_CLIENTES.BAIRRO;

/*UNION É UMA UNIÃO (JUNÇÃO DE TABELAS) POR COLUNAS IDENTICAS.
OBRIGATÓRIO OS TIPOS DAS COLUNAS SEREM IGUAIS E QUANTIDADE DE COLUNAS TAMBÉM
O UNION ALL FAZ O MESMO, MAS NÃO RETIRA DADOS IGUAIS.
PERCEBA QUE FIZ UMA UNIÃO DE DUAS SELEÇÕES*/
SELECT DISTINCT BAIRRO FROM TABELA_DE_CLIENTES
UNION 
SELECT DISTINCT BAIRRO FROM TABELA_DE_VENDEDORES;


/*UMA SUBCONSULTA É UMA CONSULTA DE ALGO DENTRO DE UMA OUTRA CONSULTA*/
SELECT NOME,BAIRRO FROM TABELA_DE_CLIENTES WHERE BAIRRO
IN (SELECT DISTINCT BAIRRO FROM TABELA_DE_VENDEDORES);


